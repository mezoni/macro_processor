// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

part of macro_processor.internal.parsers.expression_parser;

Expression _buildBinary(Expression first, List rest) {
  Expression builder(Expression result, List element) {
    return new BinaryExpression(left: result, operator: element[0], position: result.position, right: element[1]);
  };
  return _buildTree(first, rest, builder);        
}

Expression _buildTree(Expression first, List rest, builder(Expression result, List rest)) {
  var result = first;    
  for (var i = 0; i < rest.length; i++) {
    result = builder(result, rest[i]);
  }
  return result;
}

Expression _conditional(Expression condition, Expression success, Expression fail, int position) {  
  return new ConditionalExpression(condition: condition, success: success, fail: fail, position: position);
}

int _escape(String ch) {
  switch(ch) {
    case "a":
      return 0x07;
    case "b":
      return 0x08;
    case "f":
      return 0x0c;
    case "n":
      return 0x0a;
    case "r":
      return 0x0d;
    case "t":
      return 0x09;
    case "v":
      return 0x0b;
    case "\'":
      return 0x27;
    case "\"":
      return 0x22;
    case "\?":
      return 0x3f;
    default:
      throw new StateError("Unknown escape sequence: \\$ch");  
  }
}

FloatingPointLiteral _floatLiteral(String source, int position) {
  var value = _parserFloat(source);
  return new FloatingPointLiteral(position: position, text: source, value: value);
}

double _parserFloat(String source) {
  source = source.toLowerCase();
  var hex = false;
  if (source.startsWith("0x")) {
    source = source.substring(2);
    hex = true;
  }
  var length = source.length;
  var endsWith = source[length - 1];
  if (endsWith == "f" || endsWith == "l") {
    source = source.substring(0, length - 1);
  }
  if (!hex) {
    return double.parse(source);
  }
  var index = source.indexOf("p");
  var exponent = int.parse(source.substring(index + 1));
  source = source.substring(0, index);
  index = source.indexOf(".");
  int integer = 0;
  int fractional = 0;
  if (index == 0) {
    fractional = int.parse(source.substring(1), radix: 16);
  } else if (index > 0) {
    integer = int.parse(source.substring(0, index), radix: 16);
    fractional = int.parse(source.substring(index + 1), radix: 16);
  } else {
    integer = int.parse(source, radix: 16);
  }
  var d = double.parse(".$fractional") * .625;
  return (integer + d) * pow(2, exponent);
}

StringLiteral _stringLiteral(String source, List<int> characters, int position) {
  var value = "";
  if (characters != null) {
    value = new String.fromCharCodes(characters);
  }    
  return new StringLiteral(position: position, text: source, value: value);
}

SourceLine _sourceLine(List<SourceFragment> fragments, SourceFragment last, int position) {
  if (last != null) {
    fragments.add(last);
  }
  return new SourceLine(fragments: fragments, position: position); 
}

Expression _unary(String operator, Expression operand, int position) {  
  return new UnaryExpression(operand: operand, operator: operator, position: position);
}

class ExprParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["\'(\'", "\'defined\'", "constant", "identifier", "unary_operator"];
  
  static final List<String> _expect1 = <String>["\'||\'"];
  
  static final List<String> _expect10 = <String>["multiplicative_operator"];
  
  static final List<String> _expect11 = <String>["\'(\'", "\'defined\'", "constant", "identifier"];
  
  static final List<String> _expect12 = <String>["\'defined\'"];
  
  static final List<String> _expect13 = <String>["eof", "new_line"];
  
  static final List<String> _expect14 = <String>["constant"];
  
  static final List<String> _expect15 = <String>["eof"];
  
  static final List<String> _expect16 = <String>["identifier"];
  
  static final List<String> _expect17 = <String>["\'(\'"];
  
  static final List<String> _expect18 = <String>["new_line"];
  
  static final List<String> _expect19 = <String>["\'?\'"];
  
  static final List<String> _expect2 = <String>["\'&&\'"];
  
  static final List<String> _expect20 = <String>["\')\'"];
  
  static final List<String> _expect21 = <String>["\':\'"];
  
  static final List<String> _expect22 = <String>["unary_operator"];
  
  static final List<String> _expect23 = <String>["*"];
  
  static final List<String> _expect24 = <String>["P", "p"];
  
  static final List<String> _expect25 = <String>["\'", "L\'"];
  
  static final List<String> _expect26 = <String>["=="];
  
  static final List<String> _expect27 = <String>["!"];
  
  static final List<String> _expect28 = <String>["E", "e"];
  
  static final List<String> _expect29 = <String>[">"];
  
  static final List<String> _expect3 = <String>["\'|\'"];
  
  static final List<String> _expect30 = <String>[">="];
  
  static final List<String> _expect31 = <String>["0X", "0x"];
  
  static final List<String> _expect32 = <String>["\\x"];
  
  static final List<String> _expect33 = <String>["LL", "ll"];
  
  static final List<String> _expect34 = <String>["<<"];
  
  static final List<String> _expect35 = <String>["<"];
  
  static final List<String> _expect36 = <String>["<="];
  
  static final List<String> _expect37 = <String>["-"];
  
  static final List<String> _expect38 = <String>["!="];
  
  static final List<String> _expect39 = <String>["0"];
  
  static final List<String> _expect4 = <String>["\'^\'"];
  
  static final List<String> _expect40 = <String>["\\"];
  
  static final List<String> _expect41 = <String>["%"];
  
  static final List<String> _expect42 = <String>["+"];
  
  static final List<String> _expect43 = <String>["/"];
  
  static final List<String> _expect44 = <String>[];
  
  static final List<String> _expect45 = <String>["~"];
  
  static final List<String> _expect46 = <String>["\\U", "\\u"];
  
  static final List<String> _expect5 = <String>["\'&\'"];
  
  static final List<String> _expect6 = <String>["equality_operator"];
  
  static final List<String> _expect7 = <String>["relational_operator"];
  
  static final List<String> _expect8 = <String>["\'<<\'"];
  
  static final List<String> _expect9 = <String>["additive_operator"];
  
  static final List<bool> _lookahead = _unmap([0x1ffb4c1, 0x17fffffe, 0xffffffd, 0x2803, 0x0, 0x0, 0x701ffa0e, 0x697fffff, 0x7fffffff, 0x7e87ffff, 0x7fdfffff, 0x3f01, 0x100fe00, 0x6010000, 0x8000002, 0xc, 0x1ffa0600, 0x30000, 0xc0000, 0x8430000]);
  
  // '\n', '\r'
  static final List<bool> _mapping0 = _unmap([0x9]);
  
  // '\n', '\r', '\'', '\\'
  static final List<bool> _mapping1 = _unmap([0x20000009, 0x0, 0x100000]);
  
  // 'F', 'L', 'f', 'l'
  static final List<bool> _mapping2 = _unmap([0x41, 0x82]);
  
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'
  static final List<bool> _mapping3 = _unmap([0x7e03ff, 0xfc0000]);
  
  // 'L', 'l'
  static final List<bool> _mapping4 = _unmap([0x1, 0x2]);
  
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping5 = _unmap([0x43ffffff, 0x7fffffe]);
  
  // '+', '-'
  static final List<bool> _mapping6 = _unmap([0x5]);
  
  // '\"', '\'', '?', '\\', 'a', 'b', 'f', 'n', 'r', 't', 'v'
  static final List<bool> _mapping7 = _unmap([0x20000021, 0x8000000, 0x544046]);
  
  // '\t', ' '
  static final List<bool> _mapping8 = _unmap([0x800001]);
  
  // 'U', 'u'
  static final List<bool> _mapping9 = _unmap([0x1, 0x2]);
  
  // 'defined'
  static final List<int> _strings0 = <int>[100, 101, 102, 105, 110, 101, 100];
  
  // '&&'
  static final List<int> _strings1 = <int>[38, 38];
  
  // 'LL'
  static final List<int> _strings10 = <int>[76, 76];
  
  // 'll'
  static final List<int> _strings11 = <int>[108, 108];
  
  // '<<'
  static final List<int> _strings12 = <int>[60, 60];
  
  // '<='
  static final List<int> _strings13 = <int>[60, 61];
  
  // '!='
  static final List<int> _strings14 = <int>[33, 61];
  
  // '\U'
  static final List<int> _strings15 = <int>[92, 85];
  
  // '\u'
  static final List<int> _strings16 = <int>[92, 117];
  
  // '\r\n'
  static final List<int> _strings2 = <int>[13, 10];
  
  // '||'
  static final List<int> _strings3 = <int>[124, 124];
  
  // 'L''
  static final List<int> _strings4 = <int>[76, 39];
  
  // '=='
  static final List<int> _strings5 = <int>[61, 61];
  
  // '>='
  static final List<int> _strings6 = <int>[62, 61];
  
  // '\x'
  static final List<int> _strings7 = <int>[92, 120];
  
  // '0x'
  static final List<int> _strings8 = <int>[48, 120];
  
  // '0X'
  static final List<int> _strings9 = <int>[48, 88];
  
  final List<String> _tokenAliases = ["\'defined\'", "additive_operator", "\'&\'", "\'&&\'", "constant", "eof", "equality_operator", "identifier", "\'(\'", "multiplicative_operator", "new_line", "\'?\'", "relational_operator", "\')\'", "\':\'", "\'<<\'", "unary_operator", "\'|\'", "\'||\'", "\'^\'"];
  
  final List<int> _tokenFlags = [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  
  final List<String> _tokenNames = ["DEFINED", "additive_operator", "ampersand", "ampersand2", "constant", "eof", "equality_operator", "identifier", "lparen", "multiplicative_operator", "new_line", "question_mark", "relational_operator", "rparen", "semicolon", "shift_operator", "unary_operator", "vertical_line", "vertical_line2", "xor"];
  
  static final List<List<int>> _transitions0 = [[33, 33, 39, 40, 43, 43, 45, 46, 48, 57, 65, 90, 92, 92, 95, 95, 97, 122, 126, 126]];
  
  static final List<List<int>> _transitions1 = [[33, 33, 61, 61]];
  
  static final List<List<int>> _transitions10 = [[33, 33], [61, 61]];
  
  static final List<List<int>> _transitions11 = [[65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions12 = [[37, 37], [42, 42], [47, 47]];
  
  static final List<List<int>> _transitions13 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions14 = [[60, 60], [62, 62]];
  
  static final List<List<int>> _transitions15 = [[33, 33], [43, 43], [45, 45], [126, 126]];
  
  static final List<List<int>> _transitions16 = [[80, 80, 112, 112]];
  
  static final List<List<int>> _transitions17 = [[80, 80], [112, 112]];
  
  static final List<List<int>> _transitions18 = [[0, 42, 44, 44, 46, 1114111], [43, 43, 45, 45]];
  
  static final List<List<int>> _transitions19 = [[39, 39], [76, 76]];
  
  static final List<List<int>> _transitions2 = [[60, 60, 62, 62]];
  
  static final List<List<int>> _transitions20 = [[39, 39, 76, 76], [46, 46], [48, 57]];
  
  static final List<List<int>> _transitions21 = [[0, 47, 58, 1114111], [48, 57]];
  
  static final List<List<int>> _transitions22 = [[46, 46, 48, 57]];
  
  static final List<List<int>> _transitions23 = [[46, 46], [48, 57]];
  
  static final List<List<int>> _transitions24 = [[69, 69, 101, 101]];
  
  static final List<List<int>> _transitions25 = [[69, 69], [101, 101]];
  
  static final List<List<int>> _transitions26 = [[70, 70, 76, 76, 102, 102, 108, 108]];
  
  static final List<List<int>> _transitions27 = [[48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions28 = [[0, 47, 58, 64, 71, 96, 103, 1114111], [48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions29 = [[46, 46], [48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions3 = [[43, 43, 45, 45]];
  
  static final List<List<int>> _transitions30 = [[0, 47, 58, 64, 91, 91, 93, 94, 96, 96, 123, 1114111], [48, 57], [65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions31 = [[65, 90, 95, 95, 97, 122], [92, 92]];
  
  static final List<List<int>> _transitions32 = [[48, 48], [49, 57]];
  
  static final List<List<int>> _transitions33 = [[76, 76, 108, 108], [85, 85, 117, 117]];
  
  static final List<List<int>> _transitions34 = [[76, 76], [108, 108]];
  
  static final List<List<int>> _transitions35 = [[76, 76, 108, 108]];
  
  static final List<List<int>> _transitions36 = [[65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions37 = [[0, 47, 56, 1114111], [48, 55]];
  
  static final List<List<int>> _transitions38 = [[85, 85, 117, 117]];
  
  static final List<List<int>> _transitions4 = [[37, 37, 42, 42, 47, 47]];
  
  static final List<List<int>> _transitions5 = [[33, 33, 43, 43, 45, 45, 126, 126], [39, 40, 46, 46, 48, 57, 65, 90, 92, 92, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions6 = [[39, 39, 46, 46, 48, 57], [40, 40], [65, 90], [92, 92, 95, 95, 97, 99, 101, 122], [100, 100]];
  
  static final List<List<int>> _transitions7 = [[0, 9, 11, 12, 14, 1114111], [10, 10, 13, 13]];
  
  static final List<List<int>> _transitions8 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions9 = [[39, 39, 46, 46, 48, 57, 76, 76]];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<ExprParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  ExprParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {   
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];      
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var alias = _tokenAliases[_token];
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos > _tokenStart && _failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated '$name'";
        _errors.add(new ExprParserError(ExprParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed '$name'";
        _errors.add(new ExprParserError(ExprParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(alias);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_DEFINED() {
    // LEXEME (TOKEN)
    // DEFINED <- 'defined' spaces
    var $$;
    _token = 0;  
    _tokenStart = _cursor;  
    // => 'defined' spaces # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => 'defined' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'defined'
          $$ = _matchString(_strings0, 'defined');
          // <= 'defined'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'defined'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'defined' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined'
      _failure(_expect12);
    }
    // <= 'defined' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_additive_expression() {
    // SENTENCE (NONTERMINAL)
    // additive_expression <- multiplicative_expression (additive_operator multiplicative_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[10] >= pos) {
      $$ = _getFromCache(10);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[10] = pos;
    }  
    // => multiplicative_expression (additive_operator multiplicative_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => multiplicative_expression (additive_operator multiplicative_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => multiplicative_expression
          $$ = _parse_multiplicative_expression();
          // <= multiplicative_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (additive_operator multiplicative_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (additive_operator multiplicative_expression) # Choice
            switch (_getState(_transitions3)) {
              // [+] [-]
              case 0:
                // => additive_operator multiplicative_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => additive_operator
                  $$ = _parse_additive_operator();
                  // <= additive_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => multiplicative_expression
                  $$ = _parse_multiplicative_expression();
                  // <= multiplicative_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= additive_operator multiplicative_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: additive_operator
              _failure(_expect9);
            }
            // <= (additive_operator multiplicative_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (additive_operator multiplicative_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // multiplicative_expression
            final $1 = seq[0];
            // (additive_operator multiplicative_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= multiplicative_expression (additive_operator multiplicative_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= multiplicative_expression (additive_operator multiplicative_expression)* # Choice
    if (_cacheable[10]) {
      _addToCache($$, pos, 10);
    }    
    return $$;
  }
  
  dynamic _parse_additive_operator() {
    // LEXEME (TOKEN)
    // additive_operator <- plus / minus
    var $$;
    _token = 1;  
    _tokenStart = _cursor;  
    // => plus / minus # Choice
    switch (_getState(_transitions8)) {
      // [+]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => plus
        $$ = _parse_plus();
        // <= plus
        _startPos = startPos0;
        break;
      // [-]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => minus
        $$ = _parse_minus();
        // <= minus
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: additive_operator
      _failure(_expect9);
    }
    // <= plus / minus # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ampersand() {
    // LEXEME (TOKEN)
    // ampersand <- '&' spaces
    var $$;
    _token = 2;  
    _tokenStart = _cursor;  
    // => '&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&'
          $$ = '&';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '&'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&'
      _failure(_expect5);
    }
    // <= '&' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ampersand2() {
    // LEXEME (TOKEN)
    // ampersand2 <- '&&' spaces
    var $$;
    _token = 3;  
    _tokenStart = _cursor;  
    // => '&&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&&'
          $$ = _matchString(_strings1, '&&');
          // <= '&&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '&&'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&&'
      _failure(_expect2);
    }
    // <= '&&' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_and_expression() {
    // SENTENCE (NONTERMINAL)
    // and_expression <- equality_expression (ampersand equality_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[6] >= pos) {
      $$ = _getFromCache(6);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[6] = pos;
    }  
    // => equality_expression (ampersand equality_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => equality_expression (ampersand equality_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => equality_expression
          $$ = _parse_equality_expression();
          // <= equality_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (ampersand equality_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (ampersand equality_expression) # Choice
            switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
              // [&]
              case 0:
                // => ampersand equality_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => ampersand
                  $$ = _parse_ampersand();
                  // <= ampersand
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => equality_expression
                  $$ = _parse_equality_expression();
                  // <= equality_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= ampersand equality_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '&'
              _failure(_expect5);
            }
            // <= (ampersand equality_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (ampersand equality_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // equality_expression
            final $1 = seq[0];
            // (ampersand equality_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= equality_expression (ampersand equality_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= equality_expression (ampersand equality_expression)* # Choice
    if (_cacheable[6]) {
      _addToCache($$, pos, 6);
    }    
    return $$;
  }
  
  dynamic _parse_asterisk() {
    // MORHEME
    // asterisk <- '*' spaces
    var $$;
    // => '*' spaces # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: *
      _failure(_expect23);
    }
    // <= '*' spaces # Choice
    return $$;
  }
  
  dynamic _parse_binary_exponent_part() {
    // MORHEME
    // binary_exponent_part <- ('p' / 'P') (sign / '') digit_sequence
    var $$;
    // => ('p' / 'P') (sign / '') digit_sequence # Choice
    switch (_getState(_transitions16)) {
      // [P] [p]
      case 0:
        // => ('p' / 'P') (sign / '') digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('p' / 'P') # Choice
          switch (_getState(_transitions17)) {
            // [P]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => 'P'
              $$ = _matchChar(80, 'P');
              // <= 'P'
              _startPos = startPos1;
              break;
            // [p]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => 'p'
              $$ = 'p';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'p'
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: p, P
            _failure(_expect24);
          }
          // <= ('p' / 'P') # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (sign / '') # Choice
          switch (_getState(_transitions18)) {
            // [\u0000-*] [,] [.-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => ''
              success = true;
              $$ = '';
              // <= ''
              _startPos = startPos3;
              break;
            // [+] [-]
            case 1:
              while (true) {
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => sign
                $$ = _parse_sign();
                // <= sign
                _startPos = startPos4;
                if (success) break;
                var startPos5 = _startPos;
                _startPos = _cursor;
                // => ''
                success = true;
                $$ = '';
                // <= ''
                _startPos = startPos5;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (sign / '') # Choice
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ('p' / 'P')
            final $1 = seq[0];
            // (sign / '')
            final $2 = seq[1];
            // digit_sequence
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('p' / 'P') (sign / '') digit_sequence # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: p, P
      _failure(_expect24);
    }
    // <= ('p' / 'P') (sign / '') digit_sequence # Choice
    return $$;
  }
  
  dynamic _parse_c_char() {
    // MORHEME
    // c_char <- ![\n\r'\\] . / escape_sequence
    var $$;
    // => ![\n\r'\\] . / escape_sequence # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          // => ![\n\r'\\] . # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ![\n\r'\\]
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            // => [\n\r'\\]
            $$ = _matchMapping(10, 92, _mapping1);
            // <= [\n\r'\\]
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            // <= ![\n\r'\\]
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ![\n\r'\\]
              final $1 = seq[0];
              // .
              final $2 = seq[1];
              final $start = startPos0;
              $$ = $2.codeUnitAt(0);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= ![\n\r'\\] . # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => escape_sequence
          $$ = _parse_escape_sequence();
          // <= escape_sequence
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        // => ![\n\r'\\] . # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ![\n\r'\\]
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => [\n\r'\\]
          $$ = _matchMapping(10, 92, _mapping1);
          // <= [\n\r'\\]
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= ![\n\r'\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ![\n\r'\\]
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos2;
            $$ = $2.codeUnitAt(0);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= ![\n\r'\\] . # Sequence
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= ![\n\r'\\] . / escape_sequence # Choice
    return $$;
  }
  
  dynamic _parse_character_constant_base() {
    // MORHEME
    // character_constant_base <- '\'' c_char '\'' / 'L\'' c_char '\''
    var $$;
    // => '\'' c_char '\'' / 'L\'' c_char '\'' # Choice
    switch (_getState(_transitions19)) {
      // [\']
      case 0:
        // => '\'' c_char '\'' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\''
          $$ = '\'';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => c_char
          $$ = _parse_c_char();
          // <= c_char
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '\''
            final $1 = seq[0];
            // c_char
            final $2 = seq[1];
            // '\''
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new CharacterLiteral(position: $start, text: _text(), value: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\'' c_char '\'' # Sequence
        break;
      // [L]
      case 1:
        // => 'L\'' c_char '\'' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L\''
          $$ = _matchString(_strings4, 'L\'');
          // <= 'L\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => c_char
          $$ = _parse_c_char();
          // <= c_char
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // 'L\''
            final $1 = seq[0];
            // c_char
            final $2 = seq[1];
            // '\''
            final $3 = seq[2];
            final $start = startPos1;
            $$ = new CharacterLiteral(position: $start, text: _text(), value: $2);
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L\'' c_char '\'' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ', L'
      _failure(_expect25);
    }
    // <= '\'' c_char '\'' / 'L\'' c_char '\'' # Choice
    return $$;
  }
  
  dynamic _parse_conditional_expression() {
    // SENTENCE (NONTERMINAL)
    // conditional_expression <- logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[1] >= pos) {
      $$ = _getFromCache(1);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[1] = pos;
    }  
    // => logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        while (true) {
          // => logical_or_expression question_mark expression semicolon conditional_expression # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => logical_or_expression
            $$ = _parse_logical_or_expression();
            // <= logical_or_expression
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => question_mark
            $$ = _parse_question_mark();
            // <= question_mark
            if (!success) break;
            seq[1] = $$;
            // => expression
            $$ = _parse_expression();
            // <= expression
            if (!success) break;
            seq[2] = $$;
            // => semicolon
            $$ = _parse_semicolon();
            // <= semicolon
            if (!success) break;
            seq[3] = $$;
            // => conditional_expression
            $$ = _parse_conditional_expression();
            // <= conditional_expression
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              // logical_or_expression
              final $1 = seq[0];
              // question_mark
              final $2 = seq[1];
              // expression
              final $3 = seq[2];
              // semicolon
              final $4 = seq[3];
              // conditional_expression
              final $5 = seq[4];
              final $start = startPos0;
              $$ = _conditional($1, $3, $5, $start);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= logical_or_expression question_mark expression semicolon conditional_expression # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => logical_or_expression
          $$ = _parse_logical_or_expression();
          // <= logical_or_expression
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= logical_or_expression question_mark expression semicolon conditional_expression / logical_or_expression # Choice
    if (_cacheable[1]) {
      _addToCache($$, pos, 1);
    }    
    return $$;
  }
  
  dynamic _parse_constant() {
    // LEXEME (TOKEN)
    // constant <- constant_base spaces2
    var $$;
    _token = 4;  
    _tokenStart = _cursor;  
    // => constant_base spaces2 # Choice
    switch (_getState(_transitions9)) {
      // [\'] [.] [0-9] [L]
      case 0:
        // => constant_base spaces2 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => constant_base
          $$ = _parse_constant_base();
          // <= constant_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces2
          $$ = _parse_spaces2();
          // <= spaces2
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // constant_base
            final $1 = seq[0];
            // spaces2
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= constant_base spaces2 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: constant
      _failure(_expect14);
    }
    // <= constant_base spaces2 # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_constant_base() {
    // MORHEME
    // constant_base <- floating_constant_base / integer_constant_base / character_constant_base
    var $$;
    // => floating_constant_base / integer_constant_base / character_constant_base # Choice
    switch (_getState(_transitions20)) {
      // [\'] [L]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => character_constant_base
        $$ = _parse_character_constant_base();
        // <= character_constant_base
        _startPos = startPos0;
        break;
      // [.]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => floating_constant_base
        $$ = _parse_floating_constant_base();
        // <= floating_constant_base
        _startPos = startPos1;
        break;
      // [0-9]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => floating_constant_base
          $$ = _parse_floating_constant_base();
          // <= floating_constant_base
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => integer_constant_base
          $$ = _parse_integer_constant_base();
          // <= integer_constant_base
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= floating_constant_base / integer_constant_base / character_constant_base # Choice
    return $$;
  }
  
  dynamic _parse_constant_expression() {
    // SENTENCE (NONTERMINAL)
    // constant_expression <- conditional_expression
    var $$;
    // => conditional_expression # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => conditional_expression
        $$ = _parse_conditional_expression();
        // <= conditional_expression
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= conditional_expression # Choice
    return $$;
  }
  
  dynamic _parse_decimal_constant() {
    // MORHEME
    // decimal_constant <- nonzero_digit decimal_constant1
    var $$;
    // => nonzero_digit decimal_constant1 # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        // => nonzero_digit decimal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => nonzero_digit
          $$ = _parse_nonzero_digit();
          // <= nonzero_digit
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => decimal_constant1
          $$ = _parse_decimal_constant1();
          // <= decimal_constant1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // nonzero_digit
            final $1 = seq[0];
            // decimal_constant1
            final $2 = seq[1];
            final $start = startPos0;
            $$ = int.parse(_text());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= nonzero_digit decimal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= nonzero_digit decimal_constant1 # Choice
    return $$;
  }
  
  dynamic _parse_decimal_constant1() {
    // MORHEME
    // decimal_constant1 <- digit decimal_constant1 / ''
    var $$;
    // => digit decimal_constant1 / '' # Choice
    switch (_getState(_transitions21)) {
      // [\u0000-/] [:-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          // => digit decimal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit
            $$ = _parse_digit();
            // <= digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => decimal_constant1
            $$ = _parse_decimal_constant1();
            // <= decimal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= digit decimal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= digit decimal_constant1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_decimal_floating_constant() {
    // MORHEME
    // decimal_floating_constant <- decimal_floating_constant_base spaces2
    var $$;
    // => decimal_floating_constant_base spaces2 # Choice
    switch (_getState(_transitions22)) {
      // [.] [0-9]
      case 0:
        // => decimal_floating_constant_base spaces2 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => decimal_floating_constant_base
          $$ = _parse_decimal_floating_constant_base();
          // <= decimal_floating_constant_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces2
          $$ = _parse_spaces2();
          // <= spaces2
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // decimal_floating_constant_base
            final $1 = seq[0];
            // spaces2
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= decimal_floating_constant_base spaces2 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= decimal_floating_constant_base spaces2 # Choice
    return $$;
  }
  
  dynamic _parse_decimal_floating_constant_base() {
    // MORHEME
    // decimal_floating_constant_base <- fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix?
    var $$;
    // => fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix? # Choice
    switch (_getState(_transitions23)) {
      // [.]
      case 0:
        // => fractional_constant exponent_part? floating_suffix? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => fractional_constant
          $$ = _parse_fractional_constant();
          // <= fractional_constant
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => exponent_part?
          var testing0 = _testing;
          _testing = _cursor;
          // => exponent_part
          $$ = _parse_exponent_part();
          // <= exponent_part
          success = true; 
          _testing = testing0;
          // <= exponent_part?
          if (!success) break;
          seq[1] = $$;
          // => floating_suffix?
          var testing1 = _testing;
          _testing = _cursor;
          // => floating_suffix
          $$ = _parse_floating_suffix();
          // <= floating_suffix
          success = true; 
          _testing = testing1;
          // <= floating_suffix?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // fractional_constant
            final $1 = seq[0];
            // exponent_part?
            final $2 = seq[1];
            // floating_suffix?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _floatLiteral(_text(), $start);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= fractional_constant exponent_part? floating_suffix? # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => fractional_constant exponent_part? floating_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => fractional_constant
            $$ = _parse_fractional_constant();
            // <= fractional_constant
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => exponent_part?
            var testing2 = _testing;
            _testing = _cursor;
            // => exponent_part
            $$ = _parse_exponent_part();
            // <= exponent_part
            success = true; 
            _testing = testing2;
            // <= exponent_part?
            if (!success) break;
            seq[1] = $$;
            // => floating_suffix?
            var testing3 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing3;
            // <= floating_suffix?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // fractional_constant
              final $1 = seq[0];
              // exponent_part?
              final $2 = seq[1];
              // floating_suffix?
              final $3 = seq[2];
              final $start = startPos1;
              $$ = _floatLiteral(_text(), $start);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= fractional_constant exponent_part? floating_suffix? # Sequence
          if (success) break;
          // => digit_sequence exponent_part floating_suffix? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => exponent_part
            $$ = _parse_exponent_part();
            // <= exponent_part
            if (!success) break;
            seq[1] = $$;
            // => floating_suffix?
            var testing4 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing4;
            // <= floating_suffix?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // digit_sequence
              final $1 = seq[0];
              // exponent_part
              final $2 = seq[1];
              // floating_suffix?
              final $3 = seq[2];
              final $start = startPos2;
              $$ = _floatLiteral(_text(), $start);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= digit_sequence exponent_part floating_suffix? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix? # Choice
    return $$;
  }
  
  dynamic _parse_defined() {
    // SENTENCE (NONTERMINAL)
    // defined <- DEFINED lparen identifier rparen
    var $$;
    // => DEFINED lparen identifier rparen # Choice
    switch (_ch == 100 ? 0 : _ch == -1 ? 2 : 1) {
      // [d]
      case 0:
        // => DEFINED lparen identifier rparen # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DEFINED
          $$ = _parse_DEFINED();
          // <= DEFINED
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => lparen
          $$ = _parse_lparen();
          // <= lparen
          if (!success) break;
          seq[1] = $$;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          if (!success) break;
          seq[2] = $$;
          // => rparen
          $$ = _parse_rparen();
          // <= rparen
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // DEFINED
            final $1 = seq[0];
            // lparen
            final $2 = seq[1];
            // identifier
            final $3 = seq[2];
            // rparen
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new DefinedExpression(identifier: $3, position: $start);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DEFINED lparen identifier rparen # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined'
      _failure(_expect12);
    }
    // <= DEFINED lparen identifier rparen # Choice
    return $$;
  }
  
  dynamic _parse_digit() {
    // MORHEME
    // digit <- [0-9]
    var $$;
    // => [0-9] # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-9] # Choice
    return $$;
  }
  
  dynamic _parse_digit_sequence() {
    // MORHEME
    // digit_sequence <- digit+
    var $$;
    // => digit+ # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => digit+
        var testing0;
        for (var first = true, reps; ;) {  
          // => digit  
          $$ = _parse_digit();  
          // <= digit  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= digit+
        if (success) {    
          // digit+
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= digit+ # Choice
    return $$;
  }
  
  dynamic _parse_eof() {
    // LEXEME (TOKEN)
    // eof <- !.
    var $$;
    _token = 5;  
    _tokenStart = _cursor;  
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: eof
      _failure(_expect15);
    }
    // <= !. # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_eq() {
    // MORHEME
    // eq <- '==' spaces
    var $$;
    // => '==' spaces # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '==' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '=='
          $$ = _matchString(_strings5, '==');
          // <= '=='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '=='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '==' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ==
      _failure(_expect26);
    }
    // <= '==' spaces # Choice
    return $$;
  }
  
  dynamic _parse_equality_expression() {
    // SENTENCE (NONTERMINAL)
    // equality_expression <- relational_expression (equality_operator relational_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[7] >= pos) {
      $$ = _getFromCache(7);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[7] = pos;
    }  
    // => relational_expression (equality_operator relational_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => relational_expression (equality_operator relational_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => relational_expression
          $$ = _parse_relational_expression();
          // <= relational_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (equality_operator relational_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (equality_operator relational_expression) # Choice
            switch (_getState(_transitions1)) {
              // [!] [=]
              case 0:
                // => equality_operator relational_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => equality_operator
                  $$ = _parse_equality_operator();
                  // <= equality_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => relational_expression
                  $$ = _parse_relational_expression();
                  // <= relational_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= equality_operator relational_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: equality_operator
              _failure(_expect6);
            }
            // <= (equality_operator relational_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (equality_operator relational_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // relational_expression
            final $1 = seq[0];
            // (equality_operator relational_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= relational_expression (equality_operator relational_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= relational_expression (equality_operator relational_expression)* # Choice
    if (_cacheable[7]) {
      _addToCache($$, pos, 7);
    }    
    return $$;
  }
  
  dynamic _parse_equality_operator() {
    // LEXEME (TOKEN)
    // equality_operator <- eq / neq
    var $$;
    _token = 6;  
    _tokenStart = _cursor;  
    // => eq / neq # Choice
    switch (_getState(_transitions10)) {
      // [!]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => neq
        $$ = _parse_neq();
        // <= neq
        _startPos = startPos0;
        break;
      // [=]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => eq
        $$ = _parse_eq();
        // <= eq
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: equality_operator
      _failure(_expect6);
    }
    // <= eq / neq # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_escape_sequence() {
    // MORHEME
    // escape_sequence <- simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name
    var $$;
    // => simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => simple_escape_sequence
          $$ = _parse_simple_escape_sequence();
          // <= simple_escape_sequence
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => octal_escape_sequence
          $$ = _parse_octal_escape_sequence();
          // <= octal_escape_sequence
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => hexadecimal_escape_sequence
          $$ = _parse_hexadecimal_escape_sequence();
          // <= hexadecimal_escape_sequence
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => universal_character_name
          $$ = _parse_universal_character_name();
          // <= universal_character_name
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name # Choice
    return $$;
  }
  
  dynamic _parse_exclamation() {
    // MORHEME
    // exclamation <- '!' spaces
    var $$;
    // => '!' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!'
          $$ = '!';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '!'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '!'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: !
      _failure(_expect27);
    }
    // <= '!' spaces # Choice
    return $$;
  }
  
  dynamic _parse_exclusive_or_expression() {
    // SENTENCE (NONTERMINAL)
    // exclusive_or_expression <- and_expression (xor and_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[5] >= pos) {
      $$ = _getFromCache(5);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[5] = pos;
    }  
    // => and_expression (xor and_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => and_expression (xor and_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => and_expression
          $$ = _parse_and_expression();
          // <= and_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (xor and_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (xor and_expression) # Choice
            switch (_ch == 94 ? 0 : _ch == -1 ? 2 : 1) {
              // [^]
              case 0:
                // => xor and_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => xor
                  $$ = _parse_xor();
                  // <= xor
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => and_expression
                  $$ = _parse_and_expression();
                  // <= and_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= xor and_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '^'
              _failure(_expect4);
            }
            // <= (xor and_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (xor and_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // and_expression
            final $1 = seq[0];
            // (xor and_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= and_expression (xor and_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= and_expression (xor and_expression)* # Choice
    if (_cacheable[5]) {
      _addToCache($$, pos, 5);
    }    
    return $$;
  }
  
  dynamic _parse_exponent_part() {
    // MORHEME
    // exponent_part <- ('e' / 'E') (sign / '') digit_sequence
    var $$;
    // => ('e' / 'E') (sign / '') digit_sequence # Choice
    switch (_getState(_transitions24)) {
      // [E] [e]
      case 0:
        // => ('e' / 'E') (sign / '') digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('e' / 'E') # Choice
          switch (_getState(_transitions25)) {
            // [E]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => 'E'
              $$ = _matchChar(69, 'E');
              // <= 'E'
              _startPos = startPos1;
              break;
            // [e]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => 'e'
              $$ = 'e';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'e'
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: e, E
            _failure(_expect28);
          }
          // <= ('e' / 'E') # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (sign / '') # Choice
          switch (_getState(_transitions18)) {
            // [\u0000-*] [,] [.-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => ''
              success = true;
              $$ = '';
              // <= ''
              _startPos = startPos3;
              break;
            // [+] [-]
            case 1:
              while (true) {
                var startPos4 = _startPos;
                _startPos = _cursor;
                // => sign
                $$ = _parse_sign();
                // <= sign
                _startPos = startPos4;
                if (success) break;
                var startPos5 = _startPos;
                _startPos = _cursor;
                // => ''
                success = true;
                $$ = '';
                // <= ''
                _startPos = startPos5;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: 
            _failure(const [null]);
          }
          // <= (sign / '') # Choice
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // ('e' / 'E')
            final $1 = seq[0];
            // (sign / '')
            final $2 = seq[1];
            // digit_sequence
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('e' / 'E') (sign / '') digit_sequence # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: e, E
      _failure(_expect28);
    }
    // <= ('e' / 'E') (sign / '') digit_sequence # Choice
    return $$;
  }
  
  dynamic _parse_expression() {
    // SENTENCE (NONTERMINAL)
    // expression <- conditional_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[15] >= pos) {
      $$ = _getFromCache(15);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[15] = pos;
    }  
    // => conditional_expression # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => conditional_expression
        $$ = _parse_conditional_expression();
        // <= conditional_expression
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= conditional_expression # Choice
    if (_cacheable[15]) {
      _addToCache($$, pos, 15);
    }    
    return $$;
  }
  
  dynamic _parse_floating_constant_base() {
    // MORHEME
    // floating_constant_base <- decimal_floating_constant / hexadecimal_floating_constant
    var $$;
    // => decimal_floating_constant / hexadecimal_floating_constant # Choice
    switch (_getState(_transitions23)) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => decimal_floating_constant
        $$ = _parse_decimal_floating_constant();
        // <= decimal_floating_constant
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => decimal_floating_constant
          $$ = _parse_decimal_floating_constant();
          // <= decimal_floating_constant
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => hexadecimal_floating_constant
          $$ = _parse_hexadecimal_floating_constant();
          // <= hexadecimal_floating_constant
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= decimal_floating_constant / hexadecimal_floating_constant # Choice
    return $$;
  }
  
  dynamic _parse_floating_suffix() {
    // MORHEME
    // floating_suffix <- [FLfl]
    var $$;
    // => [FLfl] # Choice
    switch (_getState(_transitions26)) {
      // [F] [L] [f] [l]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [FLfl]
        $$ = _matchMapping(70, 108, _mapping2);
        // <= [FLfl]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [FLfl] # Choice
    return $$;
  }
  
  dynamic _parse_fractional_constant() {
    // MORHEME
    // fractional_constant <- digit_sequence? '.' digit_sequence / digit_sequence '.'
    var $$;
    // => digit_sequence? '.' digit_sequence / digit_sequence '.' # Choice
    switch (_getState(_transitions23)) {
      // [.]
      case 0:
        // => digit_sequence? '.' digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => digit_sequence?
          var testing0 = _testing;
          _testing = _cursor;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          success = true; 
          _testing = testing0;
          // <= digit_sequence?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // digit_sequence?
            final $1 = seq[0];
            // '.'
            final $2 = seq[1];
            // digit_sequence
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= digit_sequence? '.' digit_sequence # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => digit_sequence? '.' digit_sequence # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence?
            var testing1 = _testing;
            _testing = _cursor;
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            success = true; 
            _testing = testing1;
            // <= digit_sequence?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // digit_sequence?
              final $1 = seq[0];
              // '.'
              final $2 = seq[1];
              // digit_sequence
              final $3 = seq[2];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= digit_sequence? '.' digit_sequence # Sequence
          if (success) break;
          // => digit_sequence '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // digit_sequence
              final $1 = seq[0];
              // '.'
              final $2 = seq[1];
              final $start = startPos2;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= digit_sequence '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= digit_sequence? '.' digit_sequence / digit_sequence '.' # Choice
    return $$;
  }
  
  dynamic _parse_gt() {
    // MORHEME
    // gt <- '>' spaces
    var $$;
    // => '>' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>'
          $$ = '>';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '>'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '>'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: >
      _failure(_expect29);
    }
    // <= '>' spaces # Choice
    return $$;
  }
  
  dynamic _parse_gte() {
    // MORHEME
    // gte <- '>=' spaces
    var $$;
    // => '>=' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>='
          $$ = _matchString(_strings6, '>=');
          // <= '>='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '>='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: >=
      _failure(_expect30);
    }
    // <= '>=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_hex_quad() {
    // MORHEME
    // hex_quad <- hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit
    var $$;
    // => hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Choice
    switch (_getState(_transitions27)) {
      // [0-9] [A-F] [a-f]
      case 0:
        // => hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[2] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // hexadecimal_digit
            final $1 = seq[0];
            // hexadecimal_digit
            final $2 = seq[1];
            // hexadecimal_digit
            final $3 = seq[2];
            // hexadecimal_digit
            final $4 = seq[3];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_constant() {
    // MORHEME
    // hexadecimal_constant <- hexadecimal_prefix hexadecimal_digit hexadecimal_constant1
    var $$;
    // => hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_prefix
          $$ = _parse_hexadecimal_prefix();
          // <= hexadecimal_prefix
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_constant1
          $$ = _parse_hexadecimal_constant1();
          // <= hexadecimal_constant1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // hexadecimal_prefix
            final $1 = seq[0];
            // hexadecimal_digit
            final $2 = seq[1];
            // hexadecimal_constant1
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse(_text(2), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 0x, 0X
      _failure(_expect31);
    }
    // <= hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_constant1() {
    // MORHEME
    // hexadecimal_constant1 <- hexadecimal_digit hexadecimal_constant1 / ''
    var $$;
    // => hexadecimal_digit hexadecimal_constant1 / '' # Choice
    switch (_getState(_transitions28)) {
      // [\u0000-/] [:-@] [G-`] [g-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-9] [A-F] [a-f]
      case 1:
        while (true) {
          // => hexadecimal_digit hexadecimal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit
            $$ = _parse_hexadecimal_digit();
            // <= hexadecimal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_constant1
            $$ = _parse_hexadecimal_constant1();
            // <= hexadecimal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit hexadecimal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= hexadecimal_digit hexadecimal_constant1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_digit() {
    // MORHEME
    // hexadecimal_digit <- [0-9A-Fa-f]
    var $$;
    // => [0-9A-Fa-f] # Choice
    switch (_getState(_transitions27)) {
      // [0-9] [A-F] [a-f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9A-Fa-f]
        $$ = _matchMapping(48, 102, _mapping3);
        // <= [0-9A-Fa-f]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-9A-Fa-f] # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_digit_sequence() {
    // MORHEME
    // hexadecimal_digit_sequence <- hexadecimal_digit+
    var $$;
    // => hexadecimal_digit+ # Choice
    switch (_getState(_transitions27)) {
      // [0-9] [A-F] [a-f]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => hexadecimal_digit+
        var testing0;
        for (var first = true, reps; ;) {  
          // => hexadecimal_digit  
          $$ = _parse_hexadecimal_digit();  
          // <= hexadecimal_digit  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= hexadecimal_digit+
        if (success) {    
          // hexadecimal_digit+
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= hexadecimal_digit+ # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_escape_sequence() {
    // MORHEME
    // hexadecimal_escape_sequence <- '\\x' hexadecimal_digit hexadecimal_escape_sequence1
    var $$;
    // => '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\\x'
          $$ = _matchString(_strings7, '\\x');
          // <= '\\x'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_escape_sequence1
          $$ = _parse_hexadecimal_escape_sequence1();
          // <= hexadecimal_escape_sequence1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // '\\x'
            final $1 = seq[0];
            // hexadecimal_digit
            final $2 = seq[1];
            // hexadecimal_escape_sequence1
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse(_text(2), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \x
      _failure(_expect32);
    }
    // <= '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_escape_sequence1() {
    // MORHEME
    // hexadecimal_escape_sequence1 <- hexadecimal_digit hexadecimal_escape_sequence1 / ''
    var $$;
    // => hexadecimal_digit hexadecimal_escape_sequence1 / '' # Choice
    switch (_getState(_transitions28)) {
      // [\u0000-/] [:-@] [G-`] [g-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-9] [A-F] [a-f]
      case 1:
        while (true) {
          // => hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit
            $$ = _parse_hexadecimal_digit();
            // <= hexadecimal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_escape_sequence1
            $$ = _parse_hexadecimal_escape_sequence1();
            // <= hexadecimal_escape_sequence1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // hexadecimal_digit
              final $1 = seq[0];
              // hexadecimal_escape_sequence1
              final $2 = seq[1];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= hexadecimal_digit hexadecimal_escape_sequence1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_floating_constant() {
    // MORHEME
    // hexadecimal_floating_constant <- hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_suffix?
    var $$;
    // => hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_suffix? # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        while (true) {
          // => hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_suffix? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_prefix
            $$ = _parse_hexadecimal_prefix();
            // <= hexadecimal_prefix
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => hexadecimal_fractional_constant
            $$ = _parse_hexadecimal_fractional_constant();
            // <= hexadecimal_fractional_constant
            if (!success) break;
            seq[1] = $$;
            // => binary_exponent_part
            $$ = _parse_binary_exponent_part();
            // <= binary_exponent_part
            if (!success) break;
            seq[2] = $$;
            // => floating_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing0;
            // <= floating_suffix?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // hexadecimal_prefix
              final $1 = seq[0];
              // hexadecimal_fractional_constant
              final $2 = seq[1];
              // binary_exponent_part
              final $3 = seq[2];
              // floating_suffix?
              final $4 = seq[3];
              final $start = startPos0;
              $$ = _floatLiteral(_text(), $start);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_suffix? # Sequence
          if (success) break;
          // => hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_prefix
            $$ = _parse_hexadecimal_prefix();
            // <= hexadecimal_prefix
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            if (!success) break;
            seq[1] = $$;
            // => binary_exponent_part
            $$ = _parse_binary_exponent_part();
            // <= binary_exponent_part
            if (!success) break;
            seq[2] = $$;
            // => floating_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing1;
            // <= floating_suffix?
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // hexadecimal_prefix
              final $1 = seq[0];
              // hexadecimal_digit_sequence
              final $2 = seq[1];
              // binary_exponent_part
              final $3 = seq[2];
              // floating_suffix?
              final $4 = seq[3];
              final $start = startPos1;
              $$ = _floatLiteral(_text(), $start);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_suffix? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 0x, 0X
      _failure(_expect31);
    }
    // <= hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_suffix? # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_fractional_constant() {
    // MORHEME
    // hexadecimal_fractional_constant <- hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence / hexadecimal_digit_sequence '.'
    var $$;
    // => hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence / hexadecimal_digit_sequence '.' # Choice
    switch (_getState(_transitions29)) {
      // [.]
      case 0:
        // => hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_digit_sequence?
          var testing0 = _testing;
          _testing = _cursor;
          // => hexadecimal_digit_sequence
          $$ = _parse_hexadecimal_digit_sequence();
          // <= hexadecimal_digit_sequence
          success = true; 
          _testing = testing0;
          // <= hexadecimal_digit_sequence?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_digit_sequence
          $$ = _parse_hexadecimal_digit_sequence();
          // <= hexadecimal_digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence # Sequence
        break;
      // [0-9] [A-F] [a-f]
      case 1:
        while (true) {
          // => hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit_sequence?
            var testing1 = _testing;
            _testing = _cursor;
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            success = true; 
            _testing = testing1;
            // <= hexadecimal_digit_sequence?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence # Sequence
          if (success) break;
          // => hexadecimal_digit_sequence '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= hexadecimal_digit_sequence '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= hexadecimal_digit_sequence? '.' hexadecimal_digit_sequence / hexadecimal_digit_sequence '.' # Choice
    return $$;
  }
  
  dynamic _parse_hexadecimal_prefix() {
    // MORHEME
    // hexadecimal_prefix <- '0x' / '0X'
    var $$;
    // => '0x' / '0X' # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => '0x'
          $$ = _matchString(_strings8, '0x');
          // <= '0x'
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '0X'
          $$ = _matchString(_strings9, '0X');
          // <= '0X'
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 0x, 0X
      _failure(_expect31);
    }
    // <= '0x' / '0X' # Choice
    return $$;
  }
  
  dynamic _parse_identifier() {
    // LEXEME (TOKEN)
    // identifier <- identifier_base spaces2
    var $$;          
    var pos = _cursor;             
    if(_cachePos[24] >= pos) {
      $$ = _getFromCache(24);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[24] = pos;
    }  
    _token = 7;    
    _tokenStart = _cursor;    
    // => identifier_base spaces2 # Choice
    switch (_getState(_transitions11)) {
      // [A-Z] [\\] [_] [a-z]
      case 0:
        // => identifier_base spaces2 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => identifier_base
          $$ = _parse_identifier_base();
          // <= identifier_base
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces2
          $$ = _parse_spaces2();
          // <= spaces2
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // identifier_base
            final $1 = seq[0];
            // spaces2
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= identifier_base spaces2 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier
      _failure(_expect16);
    }
    // <= identifier_base spaces2 # Choice
    if (_cacheable[24]) {
      _addToCache($$, pos, 24);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_identifier_base() {
    // MORHEME
    // identifier_base <- identifier_nondigit identifier_base1
    var $$;
    // => identifier_nondigit identifier_base1 # Choice
    switch (_getState(_transitions11)) {
      // [A-Z] [\\] [_] [a-z]
      case 0:
        // => identifier_nondigit identifier_base1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => identifier_nondigit
          $$ = _parse_identifier_nondigit();
          // <= identifier_nondigit
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => identifier_base1
          $$ = _parse_identifier_base1();
          // <= identifier_base1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // identifier_nondigit
            final $1 = seq[0];
            // identifier_base1
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new Identifier(name: _text(), position: $start);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= identifier_nondigit identifier_base1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= identifier_nondigit identifier_base1 # Choice
    return $$;
  }
  
  dynamic _parse_identifier_base1() {
    // MORHEME
    // identifier_base1 <- identifier_nondigit identifier_base1 / digit identifier_base1 / ''
    var $$;
    // => identifier_nondigit identifier_base1 / digit identifier_base1 / '' # Choice
    switch (_getState(_transitions30)) {
      // [\u0000-/] [:-@] [[] []-^] [`] [{-\u0010ffff]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          // => digit identifier_base1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit
            $$ = _parse_digit();
            // <= digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => identifier_base1
            $$ = _parse_identifier_base1();
            // <= identifier_base1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // digit
              final $1 = seq[0];
              // identifier_base1
              final $2 = seq[1];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= digit identifier_base1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // [A-Z] [\\] [_] [a-z]
      case 2:
        while (true) {
          // => identifier_nondigit identifier_base1 # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => identifier_nondigit
            $$ = _parse_identifier_nondigit();
            // <= identifier_nondigit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => identifier_base1
            $$ = _parse_identifier_base1();
            // <= identifier_base1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // identifier_nondigit
              final $1 = seq[0];
              // identifier_base1
              final $2 = seq[1];
              final $start = startPos3;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos3;
          // <= identifier_nondigit identifier_base1 # Sequence
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= identifier_nondigit identifier_base1 / digit identifier_base1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_identifier_nondigit() {
    // MORHEME
    // identifier_nondigit <- nondigit / universal_character_name
    var $$;
    // => nondigit / universal_character_name # Choice
    switch (_getState(_transitions31)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => nondigit
        $$ = _parse_nondigit();
        // <= nondigit
        _startPos = startPos0;
        break;
      // [\\]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => universal_character_name
        $$ = _parse_universal_character_name();
        // <= universal_character_name
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= nondigit / universal_character_name # Choice
    return $$;
  }
  
  dynamic _parse_inclusive_or_expression() {
    // SENTENCE (NONTERMINAL)
    // inclusive_or_expression <- exclusive_or_expression (vertical_line exclusive_or_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[4] >= pos) {
      $$ = _getFromCache(4);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[4] = pos;
    }  
    // => exclusive_or_expression (vertical_line exclusive_or_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => exclusive_or_expression (vertical_line exclusive_or_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => exclusive_or_expression
          $$ = _parse_exclusive_or_expression();
          // <= exclusive_or_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (vertical_line exclusive_or_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (vertical_line exclusive_or_expression) # Choice
            switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
              // [|]
              case 0:
                // => vertical_line exclusive_or_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => vertical_line
                  $$ = _parse_vertical_line();
                  // <= vertical_line
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => exclusive_or_expression
                  $$ = _parse_exclusive_or_expression();
                  // <= exclusive_or_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= vertical_line exclusive_or_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '|'
              _failure(_expect3);
            }
            // <= (vertical_line exclusive_or_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (vertical_line exclusive_or_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // exclusive_or_expression
            final $1 = seq[0];
            // (vertical_line exclusive_or_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= exclusive_or_expression (vertical_line exclusive_or_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= exclusive_or_expression (vertical_line exclusive_or_expression)* # Choice
    if (_cacheable[4]) {
      _addToCache($$, pos, 4);
    }    
    return $$;
  }
  
  dynamic _parse_integer_constant_base() {
    // MORHEME
    // integer_constant_base <- decimal_constant integer_suffix? / hexadecimal_constant integer_suffix? / octal_constant integer_suffix?
    var $$;
    // => decimal_constant integer_suffix? / hexadecimal_constant integer_suffix? / octal_constant integer_suffix? # Choice
    switch (_getState(_transitions32)) {
      // [0]
      case 0:
        while (true) {
          // => hexadecimal_constant integer_suffix? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_constant
            $$ = _parse_hexadecimal_constant();
            // <= hexadecimal_constant
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => integer_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => integer_suffix
            $$ = _parse_integer_suffix();
            // <= integer_suffix
            success = true; 
            _testing = testing0;
            // <= integer_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // hexadecimal_constant
              final $1 = seq[0];
              // integer_suffix?
              final $2 = seq[1];
              final $start = startPos0;
              $$ = new IntegerLiteral(position: $start, text: _text(), value: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= hexadecimal_constant integer_suffix? # Sequence
          if (success) break;
          // => octal_constant integer_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => octal_constant
            $$ = _parse_octal_constant();
            // <= octal_constant
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => integer_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => integer_suffix
            $$ = _parse_integer_suffix();
            // <= integer_suffix
            success = true; 
            _testing = testing1;
            // <= integer_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // octal_constant
              final $1 = seq[0];
              // integer_suffix?
              final $2 = seq[1];
              final $start = startPos1;
              $$ = new IntegerLiteral(position: $start, text: _text(), value: $1);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= octal_constant integer_suffix? # Sequence
          break;
        }
        break;
      // [1-9]
      case 1:
        // => decimal_constant integer_suffix? # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => decimal_constant
          $$ = _parse_decimal_constant();
          // <= decimal_constant
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => integer_suffix?
          var testing2 = _testing;
          _testing = _cursor;
          // => integer_suffix
          $$ = _parse_integer_suffix();
          // <= integer_suffix
          success = true; 
          _testing = testing2;
          // <= integer_suffix?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // decimal_constant
            final $1 = seq[0];
            // integer_suffix?
            final $2 = seq[1];
            final $start = startPos2;
            $$ = new IntegerLiteral(position: $start, text: _text(), value: $1);
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= decimal_constant integer_suffix? # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= decimal_constant integer_suffix? / hexadecimal_constant integer_suffix? / octal_constant integer_suffix? # Choice
    return $$;
  }
  
  dynamic _parse_integer_suffix() {
    // MORHEME
    // integer_suffix <- unsigned_suffix long_long_suffix / unsigned_suffix long_suffix? / long_long_suffix unsigned_suffix? / long_suffix unsigned_suffix?
    var $$;
    // => unsigned_suffix long_long_suffix / unsigned_suffix long_suffix? / long_long_suffix unsigned_suffix? / long_suffix unsigned_suffix? # Choice
    switch (_getState(_transitions33)) {
      // [L] [l]
      case 0:
        while (true) {
          // => long_long_suffix unsigned_suffix? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => long_long_suffix
            $$ = _parse_long_long_suffix();
            // <= long_long_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => unsigned_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            success = true; 
            _testing = testing0;
            // <= unsigned_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= long_long_suffix unsigned_suffix? # Sequence
          if (success) break;
          // => long_suffix unsigned_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => long_suffix
            $$ = _parse_long_suffix();
            // <= long_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => unsigned_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            success = true; 
            _testing = testing1;
            // <= unsigned_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= long_suffix unsigned_suffix? # Sequence
          break;
        }
        break;
      // [U] [u]
      case 1:
        while (true) {
          // => unsigned_suffix long_long_suffix # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => long_long_suffix
            $$ = _parse_long_long_suffix();
            // <= long_long_suffix
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= unsigned_suffix long_long_suffix # Sequence
          if (success) break;
          // => unsigned_suffix long_suffix? # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => long_suffix?
            var testing2 = _testing;
            _testing = _cursor;
            // => long_suffix
            $$ = _parse_long_suffix();
            // <= long_suffix
            success = true; 
            _testing = testing2;
            // <= long_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= unsigned_suffix long_suffix? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= unsigned_suffix long_long_suffix / unsigned_suffix long_suffix? / long_long_suffix unsigned_suffix? / long_suffix unsigned_suffix? # Choice
    return $$;
  }
  
  dynamic _parse_logical_and_expression() {
    // SENTENCE (NONTERMINAL)
    // logical_and_expression <- inclusive_or_expression (ampersand2 inclusive_or_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[3] >= pos) {
      $$ = _getFromCache(3);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[3] = pos;
    }  
    // => inclusive_or_expression (ampersand2 inclusive_or_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => inclusive_or_expression (ampersand2 inclusive_or_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => inclusive_or_expression
          $$ = _parse_inclusive_or_expression();
          // <= inclusive_or_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (ampersand2 inclusive_or_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (ampersand2 inclusive_or_expression) # Choice
            switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
              // [&]
              case 0:
                // => ampersand2 inclusive_or_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => ampersand2
                  $$ = _parse_ampersand2();
                  // <= ampersand2
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => inclusive_or_expression
                  $$ = _parse_inclusive_or_expression();
                  // <= inclusive_or_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= ampersand2 inclusive_or_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '&&'
              _failure(_expect2);
            }
            // <= (ampersand2 inclusive_or_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (ampersand2 inclusive_or_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // inclusive_or_expression
            final $1 = seq[0];
            // (ampersand2 inclusive_or_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= inclusive_or_expression (ampersand2 inclusive_or_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= inclusive_or_expression (ampersand2 inclusive_or_expression)* # Choice
    if (_cacheable[3]) {
      _addToCache($$, pos, 3);
    }    
    return $$;
  }
  
  dynamic _parse_logical_or_expression() {
    // SENTENCE (NONTERMINAL)
    // logical_or_expression <- logical_and_expression (vertical_line2 logical_and_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[2] >= pos) {
      $$ = _getFromCache(2);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[2] = pos;
    }  
    // => logical_and_expression (vertical_line2 logical_and_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => logical_and_expression (vertical_line2 logical_and_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => logical_and_expression
          $$ = _parse_logical_and_expression();
          // <= logical_and_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (vertical_line2 logical_and_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (vertical_line2 logical_and_expression) # Choice
            switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
              // [|]
              case 0:
                // => vertical_line2 logical_and_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => vertical_line2
                  $$ = _parse_vertical_line2();
                  // <= vertical_line2
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => logical_and_expression
                  $$ = _parse_logical_and_expression();
                  // <= logical_and_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= vertical_line2 logical_and_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '||'
              _failure(_expect1);
            }
            // <= (vertical_line2 logical_and_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (vertical_line2 logical_and_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // logical_and_expression
            final $1 = seq[0];
            // (vertical_line2 logical_and_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= logical_and_expression (vertical_line2 logical_and_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= logical_and_expression (vertical_line2 logical_and_expression)* # Choice
    if (_cacheable[2]) {
      _addToCache($$, pos, 2);
    }    
    return $$;
  }
  
  dynamic _parse_long_long_suffix() {
    // MORHEME
    // long_long_suffix <- 'll' / 'LL'
    var $$;
    // => 'll' / 'LL' # Choice
    switch (_getState(_transitions34)) {
      // [L]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => 'LL'
        $$ = _matchString(_strings10, 'LL');
        // <= 'LL'
        _startPos = startPos0;
        break;
      // [l]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => 'll'
        $$ = _matchString(_strings11, 'll');
        // <= 'll'
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ll, LL
      _failure(_expect33);
    }
    // <= 'll' / 'LL' # Choice
    return $$;
  }
  
  dynamic _parse_long_suffix() {
    // MORHEME
    // long_suffix <- [Ll]
    var $$;
    // => [Ll] # Choice
    switch (_getState(_transitions35)) {
      // [L] [l]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [Ll]
        $$ = _matchMapping(76, 108, _mapping4);
        // <= [Ll]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [Ll] # Choice
    return $$;
  }
  
  dynamic _parse_lparen() {
    // LEXEME (TOKEN)
    // lparen <- '(' spaces
    var $$;          
    var pos = _cursor;             
    if(_cachePos[25] >= pos) {
      $$ = _getFromCache(25);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[25] = pos;
    }  
    _token = 8;    
    _tokenStart = _cursor;    
    // => '(' spaces # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '('
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect17);
    }
    // <= '(' spaces # Choice
    if (_cacheable[25]) {
      _addToCache($$, pos, 25);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_lsh() {
    // MORHEME
    // lsh <- '<<' spaces
    var $$;
    // => '<<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<<'
          $$ = _matchString(_strings12, '<<');
          // <= '<<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<<'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <<
      _failure(_expect34);
    }
    // <= '<<' spaces # Choice
    return $$;
  }
  
  dynamic _parse_lt() {
    // MORHEME
    // lt <- '<' spaces
    var $$;
    // => '<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<'
          $$ = '<';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <
      _failure(_expect35);
    }
    // <= '<' spaces # Choice
    return $$;
  }
  
  dynamic _parse_lte() {
    // MORHEME
    // lte <- '<=' spaces
    var $$;
    // => '<=' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<='
          $$ = _matchString(_strings13, '<=');
          // <= '<='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <=
      _failure(_expect36);
    }
    // <= '<=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_minus() {
    // MORHEME
    // minus <- '-' spaces
    var $$;
    // => '-' spaces # Choice
    switch (_ch == 45 ? 0 : _ch == -1 ? 2 : 1) {
      // [-]
      case 0:
        // => '-' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '-'
          $$ = '-';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '-'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: -
      _failure(_expect37);
    }
    // <= '-' spaces # Choice
    return $$;
  }
  
  dynamic _parse_multiplicative_expression() {
    // SENTENCE (NONTERMINAL)
    // multiplicative_expression <- unary_expression (multiplicative_operator unary_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[11] >= pos) {
      $$ = _getFromCache(11);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[11] = pos;
    }  
    // => unary_expression (multiplicative_operator unary_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => unary_expression (multiplicative_operator unary_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (multiplicative_operator unary_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (multiplicative_operator unary_expression) # Choice
            switch (_getState(_transitions4)) {
              // [%] [*] [/]
              case 0:
                // => multiplicative_operator unary_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => multiplicative_operator
                  $$ = _parse_multiplicative_operator();
                  // <= multiplicative_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => unary_expression
                  $$ = _parse_unary_expression();
                  // <= unary_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= multiplicative_operator unary_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: multiplicative_operator
              _failure(_expect10);
            }
            // <= (multiplicative_operator unary_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (multiplicative_operator unary_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // unary_expression
            final $1 = seq[0];
            // (multiplicative_operator unary_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_expression (multiplicative_operator unary_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= unary_expression (multiplicative_operator unary_expression)* # Choice
    if (_cacheable[11]) {
      _addToCache($$, pos, 11);
    }    
    return $$;
  }
  
  dynamic _parse_multiplicative_operator() {
    // LEXEME (TOKEN)
    // multiplicative_operator <- asterisk / slash / percent
    var $$;
    _token = 9;  
    _tokenStart = _cursor;  
    // => asterisk / slash / percent # Choice
    switch (_getState(_transitions12)) {
      // [%]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => percent
        $$ = _parse_percent();
        // <= percent
        _startPos = startPos0;
        break;
      // [*]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => asterisk
        $$ = _parse_asterisk();
        // <= asterisk
        _startPos = startPos1;
        break;
      // [/]
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => slash
        $$ = _parse_slash();
        // <= slash
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: multiplicative_operator
      _failure(_expect10);
    }
    // <= asterisk / slash / percent # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_neq() {
    // MORHEME
    // neq <- '!=' spaces
    var $$;
    // => '!=' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!='
          $$ = _matchString(_strings14, '!=');
          // <= '!='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '!='
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: !=
      _failure(_expect38);
    }
    // <= '!=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_new_line() {
    // LEXEME (TOKEN)
    // new_line <- '\r\n' / [\n\r]
    var $$;
    _token = 10;  
    _tokenStart = _cursor;  
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions13)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping0);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '\r\n'
          $$ = _matchString(_strings2, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping0);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: new_line
      _failure(_expect18);
    }
    // <= '\r\n' / [\n\r] # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_nondigit() {
    // MORHEME
    // nondigit <- [A-Z_a-z]
    var $$;
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions36)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping5);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [A-Z_a-z] # Choice
    return $$;
  }
  
  dynamic _parse_nonzero_digit() {
    // MORHEME
    // nonzero_digit <- [1-9]
    var $$;
    // => [1-9] # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [1-9]
        $$ = _matchRange(49, 57);
        // <= [1-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [1-9] # Choice
    return $$;
  }
  
  dynamic _parse_octal_constant() {
    // MORHEME
    // octal_constant <- '0' octal_constant1
    var $$;
    // => '0' octal_constant1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => '0' octal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '0'
          $$ = '0';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '0'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => octal_constant1
          $$ = _parse_octal_constant1();
          // <= octal_constant1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '0'
            final $1 = seq[0];
            // octal_constant1
            final $2 = seq[1];
            final $start = startPos0;
            $$ = int.parse(_text(), radix: 8);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '0' octal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 0
      _failure(_expect39);
    }
    // <= '0' octal_constant1 # Choice
    return $$;
  }
  
  dynamic _parse_octal_constant1() {
    // MORHEME
    // octal_constant1 <- octal_digit octal_constant1 / ''
    var $$;
    // => octal_digit octal_constant1 / '' # Choice
    switch (_getState(_transitions37)) {
      // [\u0000-/] [8-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-7]
      case 1:
        while (true) {
          // => octal_digit octal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => octal_constant1
            $$ = _parse_octal_constant1();
            // <= octal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= octal_digit octal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= octal_digit octal_constant1 / '' # Choice
    return $$;
  }
  
  dynamic _parse_octal_digit() {
    // MORHEME
    // octal_digit <- [0-7]
    var $$;
    // => [0-7] # Choice
    switch (_ch >= 48 && _ch <= 55 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-7]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-7]
        $$ = _matchRange(48, 55);
        // <= [0-7]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [0-7] # Choice
    return $$;
  }
  
  dynamic _parse_octal_escape_sequence() {
    // MORHEME
    // octal_escape_sequence <- '\\' octal_digit octal_digit octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit
    var $$;
    // => '\\' octal_digit octal_digit octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\' octal_digit octal_digit octal_digit # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[2] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // octal_digit
              final $2 = seq[1];
              // octal_digit
              final $3 = seq[2];
              // octal_digit
              final $4 = seq[3];
              final $start = startPos0;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\' octal_digit octal_digit octal_digit # Sequence
          if (success) break;
          // => '\\' octal_digit octal_digit # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = _matchChar(92, '\\');
            // <= '\\'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // octal_digit
              final $2 = seq[1];
              // octal_digit
              final $3 = seq[2];
              final $start = startPos1;
              $$ = int.parse(_text(1), radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\' octal_digit octal_digit # Sequence
          if (success) break;
          // => '\\' octal_digit # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = _matchChar(92, '\\');
            // <= '\\'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // octal_digit
              final $2 = seq[1];
              final $start = startPos2;
              $$ = int.parse($2, radix: 8);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= '\\' octal_digit # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \
      _failure(_expect40);
    }
    // <= '\\' octal_digit octal_digit octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit # Choice
    return $$;
  }
  
  dynamic _parse_percent() {
    // MORHEME
    // percent <- '%' spaces
    var $$;
    // => '%' spaces # Choice
    switch (_ch == 37 ? 0 : _ch == -1 ? 2 : 1) {
      // [%]
      case 0:
        // => '%' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '%'
          $$ = '%';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '%'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '%'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '%' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: %
      _failure(_expect41);
    }
    // <= '%' spaces # Choice
    return $$;
  }
  
  dynamic _parse_plus() {
    // MORHEME
    // plus <- '+' spaces
    var $$;
    // => '+' spaces # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '+'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: +
      _failure(_expect42);
    }
    // <= '+' spaces # Choice
    return $$;
  }
  
  dynamic _parse_primary_expression() {
    // SENTENCE (NONTERMINAL)
    // primary_expression <- defined / identifier / constant / lparen expression rparen
    var $$;
    // => defined / identifier / constant / lparen expression rparen # Choice
    switch (_getState(_transitions6)) {
      // [\'] [.] [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => constant
        $$ = _parse_constant();
        // <= constant
        _startPos = startPos0;
        break;
      // [(]
      case 1:
        // => lparen expression rparen # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => lparen
          $$ = _parse_lparen();
          // <= lparen
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => expression
          $$ = _parse_expression();
          // <= expression
          if (!success) break;
          seq[1] = $$;
          // => rparen
          $$ = _parse_rparen();
          // <= rparen
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // lparen
            final $1 = seq[0];
            // expression
            final $2 = seq[1];
            // rparen
            final $3 = seq[2];
            final $start = startPos1;
            $$ = new ParenthesisExpression(expression: $2, position: $start);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos1;
        // <= lparen expression rparen # Sequence
        break;
      // [A-Z]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => constant
          $$ = _parse_constant();
          // <= constant
          _startPos = startPos3;
          break;
        }
        break;
      // [\\] [_] [a-c] [e-z]
      case 3:
        var startPos4 = _startPos;
        _startPos = _cursor;
        // => identifier
        $$ = _parse_identifier();
        // <= identifier
        _startPos = startPos4;
        break;
      // [d]
      case 4:
        while (true) {
          var startPos5 = _startPos;
          _startPos = _cursor;
          // => defined
          $$ = _parse_defined();
          // <= defined
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos6;
          break;
        }
        break;
      // No matches
      // EOF
      case 5:
      case 6:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '('
      _failure(_expect11);
    }
    // <= defined / identifier / constant / lparen expression rparen # Choice
    return $$;
  }
  
  dynamic _parse_question_mark() {
    // LEXEME (TOKEN)
    // question_mark <- '?' spaces
    var $$;
    _token = 11;  
    _tokenStart = _cursor;  
    // => '?' spaces # Choice
    switch (_ch == 63 ? 0 : _ch == -1 ? 2 : 1) {
      // [?]
      case 0:
        // => '?' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '?'
          $$ = '?';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '?'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '?'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '?' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '?'
      _failure(_expect19);
    }
    // <= '?' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_relational_expression() {
    // SENTENCE (NONTERMINAL)
    // relational_expression <- shift_expression (relational_operator shift_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[8] >= pos) {
      $$ = _getFromCache(8);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[8] = pos;
    }  
    // => shift_expression (relational_operator shift_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => shift_expression (relational_operator shift_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => shift_expression
          $$ = _parse_shift_expression();
          // <= shift_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (relational_operator shift_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (relational_operator shift_expression) # Choice
            switch (_getState(_transitions2)) {
              // [<] [>]
              case 0:
                // => relational_operator shift_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => relational_operator
                  $$ = _parse_relational_operator();
                  // <= relational_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => shift_expression
                  $$ = _parse_shift_expression();
                  // <= shift_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= relational_operator shift_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: relational_operator
              _failure(_expect7);
            }
            // <= (relational_operator shift_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (relational_operator shift_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // shift_expression
            final $1 = seq[0];
            // (relational_operator shift_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= shift_expression (relational_operator shift_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= shift_expression (relational_operator shift_expression)* # Choice
    if (_cacheable[8]) {
      _addToCache($$, pos, 8);
    }    
    return $$;
  }
  
  dynamic _parse_relational_operator() {
    // LEXEME (TOKEN)
    // relational_operator <- lt / gt / lte / gte
    var $$;
    _token = 12;  
    _tokenStart = _cursor;  
    // => lt / gt / lte / gte # Choice
    switch (_getState(_transitions14)) {
      // [<]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => lt
          $$ = _parse_lt();
          // <= lt
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => lte
          $$ = _parse_lte();
          // <= lte
          _startPos = startPos1;
          break;
        }
        break;
      // [>]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => gt
          $$ = _parse_gt();
          // <= gt
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          // => gte
          $$ = _parse_gte();
          // <= gte
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: relational_operator
      _failure(_expect7);
    }
    // <= lt / gt / lte / gte # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_rparen() {
    // LEXEME (TOKEN)
    // rparen <- ')' spaces
    var $$;          
    var pos = _cursor;             
    if(_cachePos[30] >= pos) {
      $$ = _getFromCache(30);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[30] = pos;
    }  
    _token = 13;    
    _tokenStart = _cursor;    
    // => ')' spaces # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ')'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect20);
    }
    // <= ')' spaces # Choice
    if (_cacheable[30]) {
      _addToCache($$, pos, 30);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_rsh() {
    // MORHEME
    // rsh <- '<<' spaces
    var $$;
    // => '<<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<<'
          $$ = _matchString(_strings12, '<<');
          // <= '<<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '<<'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: <<
      _failure(_expect34);
    }
    // <= '<<' spaces # Choice
    return $$;
  }
  
  dynamic _parse_semicolon() {
    // LEXEME (TOKEN)
    // semicolon <- ':' spaces
    var $$;
    _token = 14;  
    _tokenStart = _cursor;  
    // => ':' spaces # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // ':'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect21);
    }
    // <= ':' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_shift_expression() {
    // SENTENCE (NONTERMINAL)
    // shift_expression <- additive_expression (shift_operator additive_expression)*
    var $$;          
    var pos = _cursor;             
    if(_cachePos[9] >= pos) {
      $$ = _getFromCache(9);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[9] = pos;
    }  
    // => additive_expression (shift_operator additive_expression)* # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => additive_expression (shift_operator additive_expression)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => additive_expression
          $$ = _parse_additive_expression();
          // <= additive_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (shift_operator additive_expression)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (shift_operator additive_expression) # Choice
            switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
              // [<]
              case 0:
                // => shift_operator additive_expression # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => shift_operator
                  $$ = _parse_shift_operator();
                  // <= shift_operator
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => additive_expression
                  $$ = _parse_additive_expression();
                  // <= additive_expression
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= shift_operator additive_expression # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '<<'
              _failure(_expect8);
            }
            // <= (shift_operator additive_expression) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (shift_operator additive_expression)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // additive_expression
            final $1 = seq[0];
            // (shift_operator additive_expression)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildBinary($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= additive_expression (shift_operator additive_expression)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= additive_expression (shift_operator additive_expression)* # Choice
    if (_cacheable[9]) {
      _addToCache($$, pos, 9);
    }    
    return $$;
  }
  
  dynamic _parse_shift_operator() {
    // LEXEME (TOKEN)
    // shift_operator <- lsh / rsh
    var $$;
    _token = 15;  
    _tokenStart = _cursor;  
    // => lsh / rsh # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          // => lsh
          $$ = _parse_lsh();
          // <= lsh
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => rsh
          $$ = _parse_rsh();
          // <= rsh
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<<'
      _failure(_expect8);
    }
    // <= lsh / rsh # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_sign() {
    // MORHEME
    // sign <- [+\-]
    var $$;
    // => [+\-] # Choice
    switch (_getState(_transitions3)) {
      // [+] [-]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [+\-]
        $$ = _matchMapping(43, 45, _mapping6);
        // <= [+\-]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [+\-] # Choice
    return $$;
  }
  
  dynamic _parse_simple_escape_sequence() {
    // MORHEME
    // simple_escape_sequence <- [\\] ["'?\\a-bfnrtv]
    var $$;
    // => [\\] ["'?\\a-bfnrtv] # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => [\\] ["'?\\a-bfnrtv] # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [\\]
          $$ = '\\';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= [\\]
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => ["'?\\a-bfnrtv]
          $$ = _matchMapping(34, 118, _mapping7);
          // <= ["'?\\a-bfnrtv]
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // [\\]
            final $1 = seq[0];
            // ["'?\\a-bfnrtv]
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _escape($1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [\\] ["'?\\a-bfnrtv] # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [\\] ["'?\\a-bfnrtv] # Choice
    return $$;
  }
  
  dynamic _parse_slash() {
    // MORHEME
    // slash <- '/' spaces
    var $$;
    // => '/' spaces # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '/' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '/'
          $$ = '/';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '/'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '/'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '/' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: /
      _failure(_expect43);
    }
    // <= '/' spaces # Choice
    return $$;
  }
  
  dynamic _parse_spaces() {
    // MORHEME
    // spaces <- [\t ]*
    var $$;
    // => [\t ]* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t ]*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => [\t ]
          $$ = _matchMapping(9, 32, _mapping8);
          // <= [\t ]
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= [\t ]*
        if (success) {    
          // [\t ]*
          final $1 = $$;
          final $start = startPos0;
          $$ = _text();
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect44);
    }
    // <= [\t ]* # Choice
    return $$;
  }
  
  dynamic _parse_spaces2() {
    // MORHEME
    // spaces2 <- spaces
    var $$;
    // => spaces # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => spaces
        $$ = _parse_spaces();
        // <= spaces
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(_expect44);
    }
    // <= spaces # Choice
    return $$;
  }
  
  dynamic _parse_tilde() {
    // MORHEME
    // tilde <- '~' spaces
    var $$;
    // => '~' spaces # Choice
    switch (_ch == 126 ? 0 : _ch == -1 ? 2 : 1) {
      // [~]
      case 0:
        // => '~' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '~'
          $$ = '~';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '~'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '~'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '~' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ~
      _failure(_expect45);
    }
    // <= '~' spaces # Choice
    return $$;
  }
  
  dynamic _parse_unary_expression() {
    // SENTENCE (NONTERMINAL)
    // unary_expression <- primary_expression / unary_operator unary_expression
    var $$;          
    var pos = _cursor;             
    if(_cachePos[12] >= pos) {
      $$ = _getFromCache(12);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[12] = pos;
    }  
    // => primary_expression / unary_operator unary_expression # Choice
    switch (_getState(_transitions5)) {
      // [!] [+] [-] [~]
      case 0:
        // => unary_operator unary_expression # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_operator
          $$ = _parse_unary_operator();
          // <= unary_operator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // unary_operator
            final $1 = seq[0];
            // unary_expression
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _unary($1, $2, $start);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_operator unary_expression # Sequence
        break;
      // [\'-(] [.] [0-9] [A-Z] [\\] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => primary_expression
        $$ = _parse_primary_expression();
        // <= primary_expression
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= primary_expression / unary_operator unary_expression # Choice
    if (_cacheable[12]) {
      _addToCache($$, pos, 12);
    }    
    return $$;
  }
  
  dynamic _parse_unary_operator() {
    // LEXEME (TOKEN)
    // unary_operator <- plus / minus / tilde / exclamation
    var $$;
    _token = 16;  
    _tokenStart = _cursor;  
    // => plus / minus / tilde / exclamation # Choice
    switch (_getState(_transitions15)) {
      // [!]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => exclamation
        $$ = _parse_exclamation();
        // <= exclamation
        _startPos = startPos0;
        break;
      // [+]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => plus
        $$ = _parse_plus();
        // <= plus
        _startPos = startPos1;
        break;
      // [-]
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => minus
        $$ = _parse_minus();
        // <= minus
        _startPos = startPos2;
        break;
      // [~]
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        // => tilde
        $$ = _parse_tilde();
        // <= tilde
        _startPos = startPos3;
        break;
      // No matches
      // EOF
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unary_operator
      _failure(_expect22);
    }
    // <= plus / minus / tilde / exclamation # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_universal_character_name() {
    // MORHEME
    // universal_character_name <- '\\U' hex_quad hex_quad / '\\u' hex_quad
    var $$;
    // => '\\U' hex_quad hex_quad / '\\u' hex_quad # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\U' hex_quad hex_quad # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\U'
            $$ = _matchString(_strings15, '\\U');
            // <= '\\U'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[1] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '\\U'
              final $1 = seq[0];
              // hex_quad
              final $2 = seq[1];
              // hex_quad
              final $3 = seq[2];
              final $start = startPos0;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\U' hex_quad hex_quad # Sequence
          if (success) break;
          // => '\\u' hex_quad # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\u'
            $$ = _matchString(_strings16, '\\u');
            // <= '\\u'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\u'
              final $1 = seq[0];
              // hex_quad
              final $2 = seq[1];
              final $start = startPos1;
              $$ = int.parse(_text(2), radix: 16);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\u' hex_quad # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: \U, \u
      _failure(_expect46);
    }
    // <= '\\U' hex_quad hex_quad / '\\u' hex_quad # Choice
    return $$;
  }
  
  dynamic _parse_unsigned_suffix() {
    // MORHEME
    // unsigned_suffix <- [Uu]
    var $$;
    // => [Uu] # Choice
    switch (_getState(_transitions38)) {
      // [U] [u]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [Uu]
        $$ = _matchMapping(85, 117, _mapping9);
        // <= [Uu]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 
      _failure(const [null]);
    }
    // <= [Uu] # Choice
    return $$;
  }
  
  dynamic _parse_vertical_line() {
    // LEXEME (TOKEN)
    // vertical_line <- '|' spaces
    var $$;
    _token = 17;  
    _tokenStart = _cursor;  
    // => '|' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '|' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '|'
          $$ = '|';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '|'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '|'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '|' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '|'
      _failure(_expect3);
    }
    // <= '|' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_vertical_line2() {
    // LEXEME (TOKEN)
    // vertical_line2 <- '||' spaces
    var $$;
    _token = 18;  
    _tokenStart = _cursor;  
    // => '||' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '||' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '||'
          $$ = _matchString(_strings3, '||');
          // <= '||'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '||'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '||' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '||'
      _failure(_expect1);
    }
    // <= '||' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_xor() {
    // LEXEME (TOKEN)
    // xor <- '^' spaces
    var $$;
    _token = 19;  
    _tokenStart = _cursor;  
    // => '^' spaces # Choice
    switch (_ch == 94 ? 0 : _ch == -1 ? 2 : 1) {
      // [^]
      case 0:
        // => '^' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '^'
          $$ = '^';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '^'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '^'
            final $1 = seq[0];
            // spaces
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '^' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '^'
      _failure(_expect4);
    }
    // <= '^' spaces # Choice
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<ExprParserError> errors() {
    if (success) {
      return <ExprParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <ExprParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<ExprParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new ExprParserError(ExprParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new ExprParserError(ExprParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_eval_line() {
    // SENTENCE (NONTERMINAL)
    // eval_line <- constant_expression (new_line / eof)
    var $$;
    // => constant_expression (new_line / eof) # Choice
    switch (_getState(_transitions0)) {
      // [!] [\'-(] [+] [--.] [0-9] [A-Z] [\\] [_] [a-z] [~]
      case 0:
        // => constant_expression (new_line / eof) # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => constant_expression
          $$ = _parse_constant_expression();
          // <= constant_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (new_line / eof) # Choice
          switch (_getState(_transitions7)) {
            // [\u0000-\t] [\u000b-\u000c] [\u000e-\u0010ffff]
            // EOF
            case 0:
            case 3:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => eof
              $$ = _parse_eof();
              // <= eof
              _startPos = startPos1;
              break;
            // [\n] [\r]
            case 1:
              while (true) {
                var startPos2 = _startPos;
                _startPos = _cursor;
                // => new_line
                $$ = _parse_new_line();
                // <= new_line
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                // => eof
                $$ = _parse_eof();
                // <= eof
                _startPos = startPos3;
                break;
              }
              break;
            // No matches
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: new_line, eof
            _failure(_expect13);
          }
          // <= (new_line / eof) # Choice
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // constant_expression
            final $1 = seq[0];
            // (new_line / eof)
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= constant_expression (new_line / eof) # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'defined', identifier, constant, '(', unary_operator
      _failure(_expect0);
    }
    // <= constant_expression (new_line / eof) # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(97);
    _cachePos = new List<int>.filled(97, -1);  
    _cacheable = new List<bool>.filled(97, false);
    _ch = -1;
    _errors = <ExprParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class ExprParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  ExprParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is ExprParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

